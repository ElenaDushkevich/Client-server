1) Клиент-серверная архитектура
Технология клиент-сервер - это вычислительная или сетевая архитектура, в которой процессы обмена данными или файлами распределены между так называемыми поставщиками (серверами) и заказчиками (клиентами). В данной технологии
есть два главных действующих лица:
- клиент - компьютер или мобильное устройство при управлении пользователем, которое отправляет запрос или команду на сервер
- сервер - аппаратный или облачный сервер, который принимает запрос и выполняет его
Фактически клиент и сервер это программное обеспечение
Обычно эти программы расположены на разных вычеслительных машинах и взаимодействуют между собой через вычислительную сеть посредством сетевых протоколов
Клиенты и серверы обмениваются сообщениями в шаблоне запрос-ответ. Клиент отправляет запрос, а сервер возвращает ответ. Сервер может получать запросы от множества различных клиентов за короткий промежуток времени.  
Двухзвенная архитектура - используется в клиент-серверных системах, где сервер отвечает на клиентские запросы напрямую и в полном объеме, при этом используя только собственные ресурсы
Трехзвенная архитектура - сетевое приложение разделено на две и более частей, каждая из которых может выполняться на отдельном компьютере. Выделенные части приложения взаимодействуют друг с другом, обмениваясь сообщениями в заранее согласованном формате.
Третьим звеном в трехзвенной архитектуре становится сервер приложений, т.е. компоненты распределяются следующим образом:
Представление данных — на стороне клиента.
Прикладной компонент — на выделенном сервере приложений (как вариант, выполняющем функции промежуточного ПО)
Управление ресурсами — на сервере БД, который и представляет запрашиваемые данные 
Архитектура клиент-сервер применяется в большом числе сетевых технологий, используемых для доступа к различным сетевым сервисам
Web-серверы - Изначально представляли доступ к гипертекстовым документам по протоколу HTTP. Сейчас поддерживают расширенные возможности, в частности паботу с бинарными файлами
Серверы приложений - это программная платформа, предназначенная для эффективного исполнения процедур (программ, скриптов), на которых построены приложения
Серверы баз данных - используются для обработки пользовательских запросов на языке SQL
Файл-серверы - хранят информацию в виде файлов и предоставляет пользователям доступ к ней
Прокси-сервер - действует как посредник, помогая пользователям получить информацию из Интернета и при этом обеспечиваю защиту сети, а также сохраняет часто запрашиваемую информацию 
в кэш-памяти на локальном диске, быстро доставляя ее пользователям без повторного обращения к Интернету
Файрволы (брандмауэры) - межсетевые экраны, анализирующие и фильтрующие проходящий трафик, с целью обеспечения безопасности сети
Почтовые серверы - предоставляют услуги по отправке и получению электронных почтовых отправлений

2) Что такое HTTP и HTTPS
HTTP (HyperText Transfer Protocol) - протокол прикладного уровня передачи данных. Протокол HTTP основан на использовании технологии «клиент-сервер»: клиент, отправляющий запрос, 
является инициатором соединения; сервер, получающий запрос, выполняет его и отправляет клиенту результат
HTTPS (HyperText Transfer Protocol Secure) — это расширение протокола HTTP, поддерживающее шифрование посредством криптографических протоколов SSL и TLS
Отличие HTTP от HTTPS:
- HTTPS не является отдельным протоколом передачи данных, а представляет собой расширение протокола HTTP с надстройкой для шифрования
- передаваемые по протоколу HTTP данные не защищены, HTTPS обеспечивает конфиденциальность информации путем ее шифрования
- HTTP использует порт 80, HTTPS - порт 443

3) HTTP методы
HTTP методы используются для того, чтобы указать серверу на то, какое действие мы хотим произвести с ресурсом. Популярные методы:
HEAD Используется для получения строки статуса и заголовка от сервера по URI без тела сообщения. Не изменяет данных
GET Используется для получения данных от сервера по указанному URI. Не изменяет данные
POST Используется для отправки данных на сервер с помощью формата HTML
PUT замещает все предыдущие данные на ресурсе новыми загруженными данными
PATCH аналогичен PUT но применяется только к фрагменту ресурса
DELETE Удаляет все текущие данные на ресурсе, определенном URI
CONNECT Устанавливает тунельное соединение с сервером по указанному URI
OPTIONS Описывает свойства соединения для указанного ресурса

4) HTTP статус коды сервера
HTTP status code является частью первой строки ответа сервера. Он предоставляет собой целое число из трех цифр. Первая цифра указывает на класс состаяния.
За кодом ответа обычно следует отделенная пробелом поясняющая фаза на английском языке, которая разъясняет человеку причину именно такого ответа. 
В настоящее время выделено 5 классов кодов состояний:
1xx: Informational (Информационные). Информационные коды состояния, сообщающие клиенту, что сервер пребывает в процессе обработки запроса. Реакция клиента на данные коды не требуется;
2xx: Success (Успешно).
200 OK (Хорошо). Появился в HTTP/1.0. Успешный запрос ресурса. Если клиентом были запрошены какие-либо данные, то они находятся в заголовке и/или теле сообщения.
3xx: Redirection (Перенаправление(переадресация)). Коды класса 3xx сообщают клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). 
Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location.
Многие клиенты при перенаправлениях с кодами 301 и 302 ошибочно применяют метод GET ко второму ресурсу несмотря на то, что к первому запрос был с иным методом. 
Чтобы избежать недоразумений в версии HTTP/1.1 были введены коды 303 и 307 вместо 302. Изменять метод запроса нужно только если сервер ответил 303. В остальных случаях следующий запрос производить с исходным методом.
302 Found (Найдено). Введено в HTTP/1.0. Запрошенный документ временно доступен по другому URI, указанному в заголовке в поле Location.
4xx: Client Error (Ошибка клиента). Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD HTTP запрос, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.
404 Not Found (Не найдено). Появился в HTTP/1.0. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URI.
429 Too Many Requests говорит о том, что пользователь отправлял чересчур много запросов за единицу времени. Возвращаемый сервером ответ содержит пояснение, а также может включать заголовок Retry-After.
Этот заголовок указывает на время, которое необходимо подождать, прежде чем повторять запрос.
5xx: Server Error (Ошибка сервера)
501
502 Bad Gateway указывает, что сервер, с которым пытался соединиться ваш компьютер или смартфон, получил неверный ответ сервера уровнем выше. 
Чаще всего это происходит из‑за проблем в работе DNS, прокси или самого хостинга (определить это очень просто, нужно лишь проверить журнал ошибок error.log).
503 Service Unavailable, это значит, что сервер либо перегружен, либо на нём проводятся технические работы. 

5) Ядро браузера 
Ядро - это программа или модуль, который отображает контент на основе языка разметки.Отвечает за получение содержимого веб-страницы (HTML, XML, изображения и т.д.), организацию информации (например, добавление CSS и т.д.) и расчет режима отображения 
веб-страницы, а затем ее вывод на монитор или принтер. Разные ядра браузеров по-разному интерпретируют синтаксис записи веб-страниц, поэтому отображение одной и той же веб-страницы в браузерах разных ядер также может быть различным. Именно поэтому 
необходимо тестировать веб-страницы в браузерах разных ядер

6) Какие браузеры какие ядра используют
Trident — движок Microsoft Internet Explorer;
Gecko — открытый движок проекта Mozilla. Используется в браузере Firefox, почтовом клиенте Thunderbird и других.
WebKit — движок для браузера Apple Safari.
Blink — движок браузера Google Chrome, Opera, Microsoft Edge, Яндекс.Браузер. Является ответвлением WebKit.

7) API (Application Programming Interface) - специальный протокол для взаимодействия компьютерных программ, который позволяет использовать функции одного приложения внутри другого
Самые популярные API интерфейсы - SOAP и REST
SOAP – Simple Object Access Protocol, т. е. простой протокол доступа к объектам. Клиент и сервер обмениваются сообщениями посредством XML
REST – это Representational State Transfer, т. е. передача репрезентативного состояния. REST определяет набор функций, таких как GET, PUT, DELETE и т. д., 
которые клиенты могут использовать для доступа к данным сервера. Клиенты и серверы обмениваются данными по протоколу HTTP

8) Эндпоинты
Endpoint или конечная точка представляет собой некий шлюз, который соединяет серверные процессы приложения с внешним интерфейсом.
Простыми словами, это адрес, на который отправляются сообщения.

9) URL (URI, URL, URN)

10) Идемпотентные HTTP методы
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера.
Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. 
Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны

11) Безопасные HTTP методы
Метод HTTP является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит операции "только чтение" (read-only). 
Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. Все безопасные методы являются также идемпотентными

12) Иденфикация, Аутентификация, Авторизация

13) IP

14) октеты в DNS

15) Что такое порт, сколько портов у Linux сервера

16) Уровни OSI

17) Хедеры http запросов
Все заголовки в протоколе HTTP разделяются на четыре основных группы:
General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
Request Headers (Заголовки запроса) — используются только в запросах клиента.
Response Headers (Заголовки ответа) — только для ответов от сервера.
Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения. 
В отдельный класс заголовки сущности выделены для того, чтобы не путать их с заголовками запроса или заголовками ответа при передаче множественного содержимого.
Все необходимые для функционирования HTTP заголовки описаны в основных RFC. При необходимости можно создавать свои заголовки.
Традиционно к именам таких дополнительных заголовков добавляют префикс "X-" для избежания конфликта имён с возможно существующими.
Строки после главной строки запроса (GET /index.html HTTP/1.1) имеют следующий формат: Параметр: значение. Таким образом задаются параметры запроса. 
Это является необязательным, все строки после главной строки запроса могут отсутствовать; в этом случае сервер принимает их значение по умолчанию или по результатам предыдущего запроса 
Параметр Connection(соединение) - может принимать значения Keep-Alive и close. В HTTP 1.0 за передачей сервером затребованных данных следует разъединение с клиентом, и транзакция считается 
завершённой, если не передан заголовок Connection: Keep Alive. В HTTP 1.1 сервер по умолчанию не разрывает соединение и клиент может посылать другие запросы. 
Поскольку во многие документы встроены другие документы - изображения, кадры, апплеты и т.д., это позволяет сэкономить время и затраты клиента, которому в противном случае пришлось бы 
для получения всего одной страницы многократно соединяться с одним и тем же сервером. Таким образом, в HTTP 1.1 транзакция может циклически повторяться, пока клиент или сервер 
не закроет соединение явно.
Параметр User-Agent - значением является "кодовое обозначение" браузера.
Параметр Accept - список поддерживаемых браузером типов содержимого в порядке их предпочтения данным браузером.
Параметр Referer - URL, с которого перешли на этот ресурс.
Параметр Host - имя домена, с которого запрашивается ресурс. Полезно, если на сервере имеется несколько виртуальных серверов под одним IP- адресом. 
В этом случае имя виртуального домена определяется по этому полю.
Параметр Accept-Language определение локали в браузере - поддерживаемый язык. Имеет значение для сервера, который может выдавать один и тот же документ в разных языковых версиях.
Параметр Cache-Control - используется для проверки того, не изменился ли документ; может использоваться как в запросе, так и в ответе, т.е. и клиент, и сервер могут решать, 
сколько времени будут действительны передаваемые ими документы.
Set-Cookie: name=value - указание браузеру сохранить Cookie. В этом случае, если куки поддерживаются браузером и их приём включён, браузер запоминает строку name=value (имя = значение) 
и отправляет её обратно серверу с каждым последующим запросом. Браузер при запросе следующей страницы вышлет заголовок Cookie: name=value. Этот запрос отличается от первого запроса тем, 
что содержит строку, которую сервер отправил браузеру ранее. Таким образом, сервер узнает, что этот запрос связан с предыдущим. Сервер отвечает, отправляя запрашиваемую страницу и, 
возможно, добавив новые куки. Для избежания межсайтового скриптинга(XSS) нужно устанавливать флаг HttpOnly, который делает cookies недоступными для скриптов со стороны клиента.
Формат ответа также имеет заголовок и тело, разделенное пустой строкой.
Параметр Content-Type (тип содержимого) - содержит обозначение типа (MIME) содержимого ответа.
Параметр Content-Length (длина содержимого) - длина содержимого ответа в байтах, а не символов. 
Начало работы с node.js - если тело сообщения содержит многобайтные символы, то необходимо использовать Buffer.byteLength() для определения количества использованных для кодирования байтов,
вместо length.
Параметр Transfer-Encoding используется, когда заранее не известен размер данных (Content-Length) в ответе сервера, например для динамически формируемых объектов. 
Параметр Last-Modified (модифицирован в последний раз) (W3C Last-Modified) - дата и время последнего изменения документа. Используя его, клиент, подобно случаю с ETag, может обращаться
 к серверу с запросом 'If-Modified-Since' — в этом случае сервер должен сравнить дату последней модификации копии, сохраненной на клиенте, с актуальной датой последней модификации.
 Если они совпадут, это значит, что копия в кэше клиента не устарела, и повторное скачивание не нужно (код ответа '304 Not Modified'). Last-Modified также необходим для корректной 
обработки сайта роботами, которые используют информацию о дате модификации страниц в целях сортировки результатов поиска по дате, а также для определения частоты обновляемости сайта.
Параметр ETag (объектная метка) - появился в HTTP 1.1(W3C ETag). ETag служит для присвоения каждой странице уникального идентификатора, значение которого меняется при изменении страницы
(документа). ETag представляет собой хеш («отпечаток») байтов документа, если в документе изменится хоть один байт, то изменится и ETag. ETag используется при кэшировании документа.
Этот заголовок сохраняется на клиенте, и в случае повторного обращения к документу позволяет браузеру обратиться к серверу с запросом ‘If-None-Match’, а сервер должен по значению 
ETag- метки определить, не изменился ли документ(страница), и если нет, ответить кодом ‘304 Not Modified’.
Параметр Expires (истечение)(W3C Expires) — он сообщает браузеру, какой временной промежуток можно считать, что копия страницы в кэше свежа, и вообще не обращаться к серверу с запросами. 
Это удобно для таких файлов, о которых вы точно знаете, что они не изменятся ближайший час/день/месяц: фоновая картинка страницы, например.